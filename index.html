<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Ù„Ø¹Ø¨Ø© Ø¨ÙƒØ± Ø§Ù„Ø¹Ù…Ù„Ø§Ù‚Ø© ÙˆØ§Ù„Ù…Ø¹ÙƒÙˆØ³Ø© ğŸ¶ğŸ”„</title>
  <style>
    :root {
      --primary: #FFC107; /* Ø°Ù‡Ø¨ÙŠ */
      --secondary: #ff5722;
      --accent: #795548; /* Ø¨Ù†ÙŠ Ø¬ÙˆØ²ÙŠ */
      --bg: #1a1a1d;
      --glass: rgba(40, 40, 50, 0.85);
      --text-glow: 0 0 15px rgba(255, 193, 7, 0.6);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    
    body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: #fff;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
      height: 100vh; height: 100dvh;
      overflow: hidden;
      display: flex; flex-direction: column;
    }

    /* Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙƒÙ†Ø© Ù„ØªØ¨Ø§ÙŠÙ† Ø£ÙØ¶Ù„ */
    body::before {
      content: ""; position: absolute; inset: 0;
      background: radial-gradient(circle at center, #2c2c34 0%, #000000 100%);
      z-index: -2;
    }

    @keyframes shake {
      0% { transform: translate(1px, 1px) rotate(0deg); }
      10% { transform: translate(-1px, -2px) rotate(-1deg); }
      20% { transform: translate(-3px, 0px) rotate(1deg); }
      30% { transform: translate(3px, 2px) rotate(0deg); }
      40% { transform: translate(1px, -1px) rotate(1deg); }
      50% { transform: translate(-1px, 2px) rotate(-1deg); }
      60% { transform: translate(-3px, 1px) rotate(0deg); }
      100% { transform: translate(1px, -2px) rotate(-1deg); }
    }
    .shake-screen { animation: shake 0.5s; }

    .hud {
      display: flex; justify-content: space-between;
      padding: 15px 25px; background: var(--glass);
      backdrop-filter: blur(15px);
      border-bottom: 2px solid rgba(255,215,0,0.2);
      box-shadow: 0 5px 20px rgba(0,0,0,0.5);
      z-index: 10;
    }

    .stat-box { display: flex; flex-direction: column; align-items: center; }
    .stat-label { font-size: 12px; color: #aaa; letter-spacing: 1px; margin-bottom: 4px;}
    .stat-value { font-size: 26px; font-weight: 900; text-shadow: var(--text-glow); color: var(--primary); }

    .game-wrap {
      flex: 1; position: relative;
      display: flex; align-items: center; justify-content: center;
      padding: 15px;
    }

    canvas {
      border-radius: 20px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
      background: #141414;
    }

    .controls-container {
      padding: 20px 20px 60px 20px;
      background: linear-gradient(to top, var(--glass), transparent);
      display: flex; justify-content: center; align-items: center;
      backdrop-filter: blur(5px);
    }

    .d-pad-grid {
      display: grid; grid-template-columns: repeat(3, 80px); grid-template-rows: repeat(2, 75px); gap: 10px;
    }

    .btn-ctrl {
      background: rgba(255, 193, 7, 0.1);
      border: 2px solid rgba(255, 193, 7, 0.3);
      border-radius: 20px; color: var(--primary); font-size: 36px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.1s;
      box-shadow: 0 5px 0 rgba(0,0,0,0.5);
    }
    .btn-ctrl:active { background: var(--primary); transform: translateY(5px); box-shadow: none; color: #000;}
    
    #btnUp { grid-column: 2; grid-row: 1; }
    #btnLeft { grid-column: 1; grid-row: 2; }
    #btnDown { grid-column: 2; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }

    .overlay {
      position: absolute; inset: 0; background: rgba(0,0,0,0.9);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; text-align: center; padding: 30px;
      backdrop-filter: blur(10px);
    }
    
    #startOverlay { z-index: 200; background: #000; }

    .card-panel {
      background: linear-gradient(145deg, rgba(50,40,40,0.95), rgba(30,20,20,0.95));
      padding: 40px; border-radius: 35px;
      border: 2px solid var(--primary);
      box-shadow: 0 0 50px rgba(255, 193, 7, 0.3);
      max-width: 500px; width: 100%;
    }

    h1 { margin: 0 0 15px; font-size: 2.2em; color: var(--primary); text-shadow: 0 0 10px rgba(255, 193, 7, 0.5); }
    .highlight { color: var(--primary); font-weight: bold; font-size: 1.1em;}
    .danger-text { color: #ff5252; font-weight: bold; font-size: 1.2em; }

    .btn-action {
      background: linear-gradient(90deg, var(--primary), #FF8F00);
      border: none; padding: 18px 50px; border-radius: 50px;
      color: #000; font-weight: 900; font-size: 24px; cursor: pointer;
      margin-top: 25px; width: 100%;
      box-shadow: 0 10px 30px -5px rgba(255, 193, 7, 0.6); transition: 0.3s;
    }
    .btn-action:hover { transform: scale(1.05); box-shadow: 0 15px 40px -5px rgba(255, 193, 7, 0.8); }

    .toast-msg {
      position: absolute; top: 15%; left: 50%; transform: translateX(-50%) scale(0.8);
      background: rgba(0,0,0,0.9); padding: 15px 30px; border-radius: 40px;
      font-weight: 800; font-size: 20px; border: 3px solid var(--primary);
      color: var(--primary);
      opacity: 0; pointer-events: none; transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 50;
      box-shadow: 0 0 30px rgba(255, 193, 7, 0.4);
    }
    .toast-msg.show { opacity: 1; transform: translateX(-50%) scale(1); top: 20%; }

  </style>
</head>
<body id="mainBody">

<div id="startOverlay" class="overlay">
  <div class="card-panel" style="cursor: pointer; transform: scale(1.1);" onclick="initAudioAndShowMenu()">
      <h1 style="font-size: 5em; margin-bottom: 0;">ğŸ”„ğŸ¶</h1>
      <h1>Ø§Ø¶ØºØ· Ù„Ù„Ø¨Ø¯Ø¡</h1>
      <p class="danger-text">âš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ù…Ø¹ÙƒÙˆØ³Ø©!</p>
  </div>
</div>

<div class="hud">
  <div class="stat-box">
    <span class="stat-label">Ø§Ù„Ù†Ù‚Ø§Ø·</span>
    <span id="scoreLbl" class="stat-value">0</span>
  </div>
  <div class="stat-box">
    <span class="stat-label">Ø§Ù„Ø£Ø­Ø°ÙŠØ© ğŸ‘Ÿ</span>
    <span id="eatenLbl" class="stat-value">0</span>
  </div>
</div>

<div class="game-wrap" id="gameWrapper">
  <canvas id="gameCanvas"></canvas>
  <div id="toastBox" class="toast-msg"></div>

  <div id="menuOverlay" class="overlay" style="display: none;">
    <div class="card-panel">
      <h1 id="menuTitle">ğŸ¶ Ø¨ÙƒØ± Ø§Ù„Ø¹Ù…Ù„Ø§Ù‚ ÙˆØ§Ù„Ù…Ø¹ÙƒÙˆØ³</h1>
      <p style="color: #ddd; font-size: 17px; line-height: 1.8;">
        <span class="danger-text">Ø§Ù†ØªØ¨Ù‡! Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ù…Ù‚Ù„ÙˆØ¨Ø© ØªÙ…Ø§Ù…Ø§Ù‹.</span><br>
        Ø§Ù„ÙŠÙ…ÙŠÙ† ÙŠØµØ¨Ø­ ÙŠØ³Ø§Ø±Ø§Ù‹ØŒ ÙˆØ§Ù„Ø£Ø¹Ù„Ù‰ ÙŠØµØ¨Ø­ Ø£Ø³ÙÙ„Ø§Ù‹.<br>
        Ø§Ù„Ø­ÙŠØ© Ø£ÙƒØ¨Ø±ØŒ ÙˆØ§Ù„ØºØ§Ø¦Ø· Ø§Ù„Ø°Ù‡Ø¨ÙŠ Ø£Ø¶Ø®Ù…!<br>
        Ø§Ø¨Ø­Ø« Ø¹Ù† <span class="highlight">Ø§Ù„ØºØ§Ø¦Ø· Ø§Ù„Ø¬ÙˆØ²ÙŠ Ø§Ù„Ù…Ø´Ø¹</span> (+150 Ù†Ù‚Ø·Ø©).
      </p>
      <button id="playBtn" class="btn-action">Ù‚Ø¨Ù„Øª Ø§Ù„ØªØ­Ø¯ÙŠ!</button>
    </div>
  </div>
</div>

<div class="controls-container">
  <div class="d-pad-grid">
    <div id="btnUp" class="btn-ctrl">â¬†ï¸</div>
    <div id="btnLeft" class="btn-ctrl">â¬…ï¸</div>
    <div id="btnDown" class="btn-ctrl">â¬‡ï¸</div>
    <div id="btnRight" class="btn-ctrl">â¡ï¸</div>
  </div>
</div>

<script>
  const GRID_SIZE = 20; // ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ø¬Ø¹Ù„ Ø§Ù„Ø­ÙŠØ© ØªØ¨Ø¯Ùˆ Ø£ÙƒØ¨Ø± Ù†Ø³Ø¨ÙŠØ§Ù‹
  let TILE = 0;
  
  let gameState = {
    snake: [], 
    dir: {x:1, y:0},
    nextDir: {x:1, y:0},
    food: null, bonus: null,
    score: 0, eaten: 0,
    speed: 120,
    isRunning: false,
    startTime: 0
  };

  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d", { alpha: false });

  // --- Ù†Ø¸Ø§Ù… Ø§Ù„ØµÙˆØª ---
  let audioCtx;
  let bgmOscillators = [];
  let isAudioInit = false;

  function sfx(freq, duration, type="sine", vol=0.2, detune=0) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.value = freq; osc.detune.value = detune;
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  }

  function startBGM() {
      if(!audioCtx) return;
      stopBGM();
      const bass = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      bass.type = 'triangle';
      bass.frequency.setValueAtTime(90, audioCtx.currentTime); // Ù†ØºÙ…Ø© Ø£Ø¹Ù…Ù‚
      bassGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      bass.connect(bassGain); bassGain.connect(audioCtx.destination);
      bass.start();
      bgmOscillators.push(bass);
      
      setInterval(() => {
          if(audioCtx.state === 'running' && gameState.isRunning) {
               sfx(300, 0.1, "square", 0.05);
          }
      }, 800);
  }

  function stopBGM() {
      bgmOscillators.forEach(osc => osc.stop());
      bgmOscillators = [];
  }
  
  function initAudioAndShowMenu() {
      if (!isAudioInit) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          sfx(0,0, 'sine', 0); 
          isAudioInit = true;
          startBGM();
      }
      document.getElementById("startOverlay").style.display = "none";
      document.getElementById("menuOverlay").style.display = "flex";
      resizeGame();
  }

  // --- Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±Ø³Ù… (Ø§Ù„Ù…ÙƒØ¨Ø±Ø© ÙˆØ§Ù„ÙˆØ§Ø¶Ø­Ø©) ---
  function drawRoundedEllipse(ctx, x, y, w, h, color, rotation=0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(0, 0, w/2, h/2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
  }

  function drawRealisticSnake(time) {
    for (let i = gameState.snake.length - 1; i >= 0; i--) {
      const segment = gameState.snake[i];
      const cx = (segment.x + 0.5) * TILE;
      const cy = (segment.y + 0.5) * TILE;
      
      let angle = 0;
      if (i > 0) {
          const prev = gameState.snake[i-1];
          const dx = prev.x - segment.x;
          const dy = prev.y - segment.y;
          if(Math.abs(dx) > 1 || Math.abs(dy) > 1) angle = Math.atan2(-dy, -dx);
          else angle = Math.atan2(dy, dx);
      } else {
          angle = Math.atan2(gameState.dir.y, gameState.dir.x);
      }

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);

      if (i === 0) {
        // --- Ø±Ø³Ù… Ø±Ø£Ø³ Ø§Ù„ÙƒÙ„Ø¨ (Ù…ÙƒØ¨Ø± Ø¬Ø¯Ø§Ù‹) ---
        const headSize = TILE * 1.6; // Ø²ÙŠØ§Ø¯Ø© ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø­Ø¬Ù…
        
        const furGrad = ctx.createRadialGradient(0, 0, headSize*0.2, 0, 0, headSize*0.6);
        furGrad.addColorStop(0, "#E6B89C"); // Ø£Ù„ÙˆØ§Ù† Ø£ÙØªØ­ ÙˆØ£ÙˆØ¶Ø­
        furGrad.addColorStop(1, "#A66D3A");
        
        drawRoundedEllipse(ctx, 0, 0, headSize, headSize*0.85, furGrad);
        drawRoundedEllipse(ctx, headSize*0.25, 0, headSize*0.5, headSize*0.4, "#FCE4EC"); // Snout Ø£ÙØªØ­

        drawRoundedEllipse(ctx, headSize*0.45, 0, headSize*0.2, headSize*0.14, "#2c1b18"); // Ø§Ù„Ø£Ù†Ù
        
        const eyeY = -headSize*0.16;
        const eyeX = headSize*0.12;
        drawRoundedEllipse(ctx, eyeX, eyeY, headSize*0.16, headSize*0.16, "white");
        drawRoundedEllipse(ctx, eyeX, -eyeY, headSize*0.16, headSize*0.16, "white");
        drawRoundedEllipse(ctx, eyeX+3, eyeY, headSize*0.09, headSize*0.09, "#000");
        drawRoundedEllipse(ctx, eyeX+3, -eyeY, headSize*0.09, headSize*0.09, "#000");

        const earWag = Math.sin(time / 120) * 0.08;
        ctx.fillStyle = "#795548"; 
        ctx.beginPath(); ctx.ellipse(-headSize*0.25, -headSize*0.38, headSize*0.16, headSize*0.32, -0.4 + earWag, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(-headSize*0.25, headSize*0.38, headSize*0.16, headSize*0.32, 0.4 - earWag, 0, Math.PI*2); ctx.fill();

        // Ø§Ù„Ø§Ø³Ù… Ø£ÙƒØ¨Ø± ÙˆØ£ÙˆØ¶Ø­
        ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = TILE * 0.08;
        ctx.font = `900 ${TILE * 0.5}px Tahoma`;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.rotate(Math.PI / 2); 
        ctx.strokeText("Ø¨ÙƒØ±", 0, -headSize*0.05);
        ctx.fillText("Ø¨ÙƒØ±", 0, -headSize*0.05);

      } else {
        // --- Ø±Ø³Ù… Ø§Ù„Ø¬Ø³Ù… (Ù…ÙƒØ¨Ø±) ---
        const bodySize = TILE * 1.2; // Ø§Ù„Ø¬Ø³Ù… Ø£Ø¹Ø±Ø¶ Ù…Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ Ù†ÙØ³Ù‡
        const bodyGrad = ctx.createLinearGradient(-bodySize/2, -bodySize/2, bodySize/2, bodySize/2);
        bodyGrad.addColorStop(0, i%2===0 ? "#C78D5F" : "#D9A575"); // Ø£Ù„ÙˆØ§Ù† Ø£ÙˆØ¶Ø­
        bodyGrad.addColorStop(1, "#8D5524");

        drawRoundedEllipse(ctx, 0, 0, bodySize*1.15, bodySize*0.85, bodyGrad);
      }
      ctx.restore();
    }
  }

  function drawItems(time) {
    if(gameState.food) {
        const pulse = 1 + Math.sin(time * 0.01) * 0.15;
        ctx.font = `${TILE * 1.3 * pulse}px Arial`; // Ø­Ø°Ø§Ø¡ Ø£ÙƒØ¨Ø±
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 10;
        ctx.fillText(gameState.food.type, (gameState.food.x+0.5)*TILE, (gameState.food.y+0.55)*TILE);
        ctx.shadowBlur = 0;
    }
    
    // --- Ø±Ø³Ù… Ø§Ù„ØºØ§Ø¦Ø· Ø§Ù„Ø¬ÙˆØ²ÙŠ Ø§Ù„Ø°Ù‡Ø¨ÙŠ Ø§Ù„Ø¶Ø®Ù… ---
    if(gameState.bonus) {
        const x = (gameState.bonus.x+0.5)*TILE;
        const y = (gameState.bonus.y+0.5)*TILE;
        
        // 1. Ø§Ù„Ù‡Ø§Ù„Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© Ø§Ù„Ù…Ø´Ø¹Ø© Ø§Ù„Ø¶Ø®Ù…Ø©
        const glowSize = TILE * (1.5 + Math.sin(time * 0.025) * 0.5); // Ù‡Ø§Ù„Ø© Ø¶Ø®Ù…Ø© Ø¬Ø¯Ø§Ù‹
        const glow = ctx.createRadialGradient(x, y, TILE*0.5, x, y, glowSize);
        glow.addColorStop(0, "rgba(255, 215, 0, 1)"); /* Ø°Ù‡Ø¨ÙŠ Ù‚ÙˆÙŠ ÙÙŠ Ø§Ù„ÙˆØ³Ø· */
        glow.addColorStop(0.6, "rgba(255, 160, 0, 0.6)");
        glow.addColorStop(1, "rgba(255, 215, 0, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath(); ctx.arc(x, y, glowSize, 0, Math.PI*2); ctx.fill();

        // 2. Ø±Ø³Ù… Ø¬Ø³Ù… Ø§Ù„ØºØ§Ø¦Ø· (Ù„ÙˆÙ† Ø¬ÙˆØ²ÙŠ) Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¥ÙŠÙ…ÙˆØ¬ÙŠ
        const poopSize = TILE * 0.9; // Ø­Ø¬Ù… ÙƒØ¨ÙŠØ±
        // Ù‚Ø§Ø¹Ø¯Ø©
        drawRoundedEllipse(ctx, x, y + poopSize*0.25, poopSize*1.3, poopSize*0.6, "#5D4037");
        // ÙˆØ³Ø·
        drawRoundedEllipse(ctx, x, y, poopSize*1.1, poopSize*0.6, "#795548");
        // Ù‚Ù…Ø©
        drawRoundedEllipse(ctx, x, y - poopSize*0.3, poopSize*0.7, poopSize*0.5, "#8D6E63");
        
        // Ù„Ù…Ø¹Ø© Ø°Ù‡Ø¨ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù…Ø©
        ctx.shadowColor = "#FFD700"; ctx.shadowBlur = 20;
        drawRoundedEllipse(ctx, x+poopSize*0.1, y - poopSize*0.35, poopSize*0.2, poopSize*0.15, "#FFECB3");
        ctx.shadowBlur = 0;
    }
  }

  // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø© ---
  function update() {
    if(!gameState.isRunning) return;

    gameState.dir = gameState.nextDir;
    let nx = (gameState.snake[0].x + gameState.dir.x + GRID_SIZE) % GRID_SIZE;
    let ny = (gameState.snake[0].y + gameState.dir.y + GRID_SIZE) % GRID_SIZE;

    for(let i = 3; i < gameState.snake.length; i++) {
        if(gameState.snake[i].x === nx && gameState.snake[i].y === ny) return gameOver();
    }

    gameState.snake.unshift({x: nx, y: ny});

    let ate = false;
    if (gameState.food && nx === gameState.food.x && ny === gameState.food.y) {
        gameState.score += 10; gameState.eaten++;
        sfx(600, 0.08, 'square'); 
        showToast("ğŸ‘Ÿ Ø£ÙƒÙ„Øª Ø­Ø°Ø§Ø¡!", false);
        spawnFood();
        ate = true;
        if(gameState.eaten % 4 === 0 && gameState.speed > 80) gameState.speed -= 5;
    }
    else if(gameState.bonus && nx === gameState.bonus.x && ny === gameState.bonus.y) {
        gameState.score += 150; gameState.eaten += 5;
        document.getElementById('mainBody').classList.add('shake-screen');
        setTimeout(()=>document.getElementById('mainBody').classList.remove('shake-screen'), 600);
        [500, 700, 900, 1200].forEach((f,i) => setTimeout(()=>sfx(f, 0.25, 'sawtooth', 0.3), i*80));
        showToast("ğŸ’© ØºØ§Ø¦Ø· Ø°Ù‡Ø¨ÙŠ Ø¹Ù…Ù„Ø§Ù‚! +150", true);
        gameState.bonus = null;
        ate = true;
    }

    if(!ate) gameState.snake.pop();
    updateHUD();
  }

  function gameLoop(timeStamp) {
    ctx.fillStyle = "#0a0a0c"; ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ø±Ø³Ù… Ø§Ù„Ø£Ø±Ø¶ÙŠØ© (Ù…Ø±Ø¨Ø¹Ø§Øª Ø¨Ø§Ù‡ØªØ©)
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    for(let i=0; i<GRID_SIZE; i++) {
        for(let j=0; j<GRID_SIZE; j++) {
            if((i+j)%2===0) ctx.fillRect(i*TILE, j*TILE, TILE, TILE);
        }
    }

    if (timeStamp - gameState.startTime > gameState.speed) {
        update();
        gameState.startTime = timeStamp;
    }
    
    drawItems(timeStamp);
    drawRealisticSnake(timeStamp);
    if(gameState.isRunning) requestAnimationFrame(gameLoop);
  }

  function spawnFood() {
    let pos = getFreePosition();
    gameState.food = { ...pos, type: ["ğŸ‘Ÿ","ğŸ‘","ğŸ¥¾"][Math.floor(Math.random()*3)] };
    if(Math.random() < 0.2 && !gameState.bonus) {
        let bonusPos = getFreePosition();
        gameState.bonus = { ...bonusPos };
        setTimeout(() => { if(gameState.bonus && gameState.bonus.x === bonusPos.x) gameState.bonus = null; }, 5000);
    }
  }

  function getFreePosition() {
      let x, y, isFree;
      do {
          x = Math.floor(Math.random() * GRID_SIZE);
          y = Math.floor(Math.random() * GRID_SIZE);
          isFree = !gameState.snake.some(s => s.x === x && s.y === y) && 
                   (!gameState.food || (gameState.food.x !== x || gameState.food.y !== y));
      } while(!isFree);
      return {x, y};
  }

  function startGame() {
    gameState.snake = [{x: Math.floor(GRID_SIZE/2), y: Math.floor(GRID_SIZE/2)}];
    gameState.snake.push({x: gameState.snake[0].x-1, y: gameState.snake[0].y});
    gameState.snake.push({x: gameState.snake[0].x-2, y: gameState.snake[0].y});
    gameState.dir = {x:1, y:0}; gameState.nextDir = {x:1, y:0};
    gameState.score = 0; gameState.eaten = 0; gameState.speed = 120;
    gameState.bonus = null; gameState.isRunning = true;
    updateHUD(); spawnFood();
    document.getElementById("menuOverlay").style.display = "none";
    gameState.startTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    gameState.isRunning = false;
    sfx(150, 0.6, 'sawtooth', 0.6);
    document.getElementById("menuTitle").innerHTML = "ğŸ’¥ Ø®Ø³Ø±Øª! Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª ØµØ¹Ø¨Ø©ØŸ";
    document.querySelector("#menuOverlay p").innerHTML = `Ø§Ù„Ù†ØªÙŠØ¬Ø©: <span class="highlight">${gameState.score}</span> | Ø§Ù„Ø£Ø­Ø°ÙŠØ©: ${gameState.eaten}<br><span class="danger-text">ØªØ°ÙƒØ±: Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ù…Ø¹ÙƒÙˆØ³Ø©!</span>`;
    document.getElementById("playBtn").textContent = "Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ (Ø¨Ø¹ÙƒØ³ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª)";
    document.getElementById("menuOverlay").style.display = "flex";
  }

  function resizeGame() {
    const wrapper = document.getElementById("gameWrapper");
    const size = Math.min(wrapper.clientWidth, wrapper.clientHeight) - 20;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr; canvas.height = size * dpr;
    canvas.style.width = size + "px"; canvas.style.height = size + "px";
    ctx.scale(dpr, dpr);
    TILE = size / GRID_SIZE;
    if(!gameState.isRunning && isAudioInit) drawRealisticSnake(0);
  }

  function updateHUD() {
      document.getElementById("scoreLbl").textContent = gameState.score;
      document.getElementById("eatenLbl").textContent = gameState.eaten;
  }

  function showToast(msg, isImportant) {
      const t = document.getElementById("toastBox");
      t.textContent = msg;
      t.style.borderColor = isImportant ? "#FFC107" : "rgba(255,255,255,0.5)";
      t.style.color = isImportant ? "#FFC107" : "#fff";
      t.style.boxShadow = isImportant ? "0 0 30px var(--primary)" : "none";
      t.classList.add("show");
      setTimeout(() => t.classList.remove("show"), 1500);
  }

  // --- Ø§Ù„ØªØ­ÙƒÙ… (Ø§Ù„Ù…Ø¹ÙƒÙˆØ³!) ---
  function setDir(x, y) {
      // Ù‡Ù†Ø§ ÙŠÙƒÙ…Ù† Ø§Ù„Ø³Ø±: Ù†Ù‚ÙˆÙ… Ø¨Ø¹ÙƒØ³ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª (Ø¶Ø±Ø¨ ÙÙŠ -1)
      const reversedX = -x;
      const reversedY = -y;

      if (gameState.dir.x !== -reversedX && gameState.dir.y !== -reversedY) {
          gameState.nextDir = {x: reversedX, y: reversedY};
          if(gameState.isRunning) sfx(1000, 0.02, 'sine', 0.1);
      }
  }

  // Ø§Ù„Ø£Ø²Ø±Ø§Ø± ØªØ±Ø³Ù„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØŒ ÙˆØ§Ù„Ø¯Ø§Ù„Ø© setDir ØªØ¹ÙƒØ³Ù‡
  document.getElementById("btnUp").addEventListener('pointerdown', e => { e.preventDefault(); setDir(0, -1); });
  document.getElementById("btnDown").addEventListener('pointerdown', e => { e.preventDefault(); setDir(0, 1); });
  document.getElementById("btnLeft").addEventListener('pointerdown', e => { e.preventDefault(); setDir(-1, 0); });
  document.getElementById("btnRight").addEventListener('pointerdown', e => { e.preventDefault(); setDir(1, 0); });
  document.getElementById("playBtn").onclick = startGame;

  window.addEventListener("keydown", e => {
      // Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø£ÙŠØ¶Ø§Ù‹ ÙŠØ±Ø³Ù„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ Ù„ÙŠØªÙ… Ø¹ÙƒØ³Ù‡
      if(["ArrowUp","w"].includes(e.key)) setDir(0, -1);
      if(["ArrowDown","s"].includes(e.key)) setDir(0, 1);
      if(["ArrowLeft","a"].includes(e.key)) setDir(-1, 0);
      if(["ArrowRight","d"].includes(e.key)) setDir(1, 0);
  });
  
  window.addEventListener("resize", resizeGame);
</script>
</body>
</html>
