<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙˆØ¯Ø© â€” Ù„ÙÙ‘ Ø¹Ù†Ø¯ Ø§Ù„Ø­ÙˆØ§Ù + Ø¬Ø§Ø¦Ø²Ø© ğŸ’© Ã—5</title>
  <style>
    :root{
      --bg:#14161a;
      --panel:#1c2026;
      --accent:#00d0b0;
      --accent2:#ffd166;
      --danger:#ff4d4f;
      --text:#e8ecef;
      --snakeBorder:#083d2d;
      --snakeFill1:#1bc8a8;
      --snakeFill2:#0fb18c;

      --btnGrad1:#1bd0b8;
      --btnGrad2:#16a085;
      --btnBorder:#2e3a44;
      --btnGlow:#19f0d6;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1000px 600px at 50% -10%, #222a33 0, var(--bg) 60%);
      color:var(--text); font-family:"Segoe UI", Tahoma, Arial, system-ui, -apple-system;
      display:flex; align-items:center; justify-content:center; min-height:100vh; padding:12px;
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{ width:min(95vw, 720px); margin:auto; }
    h1{ margin:0 0 6px; font-size:clamp(18px, 4.6vw, 28px); }
    .sub{ margin:0 0 12px; color:#aeb8c4; font-size:clamp(12px, 2.8vw, 14px); }

    .hud{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background:linear-gradient(180deg, #1e232a 0, var(--panel) 100%);
      border:1px solid #2a3038; border-radius:12px; padding:8px 10px; margin-bottom:10px;
    }
    .stat{display:flex; gap:6px; align-items:baseline; font-weight:800; font-size:clamp(14px, 3.5vw, 16px)}
    .v{color:var(--accent)}
    .btns{display:flex; gap:8px; flex-wrap:wrap}
    button{
      background:linear-gradient(180deg, var(--btnGrad1), var(--btnGrad2));
      color:#002a24; border:1px solid var(--btnBorder); border-radius:12px;
      padding:10px 16px; font-weight:900; cursor:pointer; transition:transform .08s ease, box-shadow .2s ease, filter .2s ease;
      font-size:clamp(14px, 3.6vw, 16px);
      box-shadow: 0 6px 18px rgba(0,0,0,.25), 0 0 0 rgba(25,240,214,0);
    }
    button:hover{ filter:brightness(1.05); box-shadow: 0 6px 18px rgba(0,0,0,.25), 0 0 20px rgba(25,240,214,.25); }
    button:active{ transform:scale(.97); }
    button.sec{
      background:linear-gradient(180deg, #2f3946, #2b3440);
      color:#e5eef5; border:1px solid #394352
    }

    .canvas-wrap{
      position:relative; border-radius:14px; overflow:hidden;
      border:1px solid #2a3038;
      box-shadow: 0 10px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
      background:#0f1216;
      touch-action: none; /* ÙŠÙ…Ù†Ø¹ Ø³Ø­Ø¨/Ø²ÙˆÙ… Ø§Ù„ØµÙØ­Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨ */
    }
    canvas{
      width:100%; height:auto; display:block;
      background:repeating-linear-gradient(0deg, #0f1216 0 24px, #11161c 24px 48px);
      image-rendering: pixelated;
    }

    /* ØªÙˆØ³Øª Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© */
    .toast{
      position:absolute; top:10px; left:50%;
      transform:translateX(-50%) translateY(-12px);
      opacity:0; transition: opacity .25s ease, transform .25s ease;
      background:#15222b; color:#eaf6f3; border:1px solid #2a3038;
      padding:8px 14px; border-radius:999px; font-weight:800; letter-spacing:.2px;
      box-shadow:0 6px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
      pointer-events:none; font-size:14px;
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); }

    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:linear-gradient(180deg, rgba(20,22,26,.55), rgba(20,22,26,.75));
      backdrop-filter:saturate(120%) blur(2px);
      text-align:center; padding:16px;
    }
    .card{
      background:#11161c; border:1px solid #2a3038; border-radius:14px; padding:16px; max-width:540px;
    }
    .card h2{margin:0 0 8px}
    .tips{font-size:14px; color:#b7c3cf; line-height:1.6; text-align:justify}

    /* Ø£Ø²Ø±Ø§Ø± ØªØ­ÙƒÙ… Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ â€” ØªØ±ØªÙŠØ¨ Ø«Ø§Ø¨Øª ÙˆØ§ØªØ¬Ø§Ù‡ Ø«Ø§Ø¨Øª ÙˆØ­Ø¯ÙŠØ« */
    .mobile-ctrl{
      direction:ltr; /* ÙŠÙ…Ù†Ø¹ Ø¹ÙƒØ³ Ø§Ù„Ø£Ù…Ø§ÙƒÙ† ÙÙŠ RTL */
      display:grid;
      grid-template-columns:minmax(84px, 30%) minmax(84px, 30%) minmax(84px, 30%);
      grid-template-areas:
        ". up ."
        "left down right";
      gap:12px; justify-content:center; margin:12px 0 0;
      user-select:none; 
      touch-action:none; /* ÙŠÙ…Ù†Ø¹ Ø§Ù„Ø³Ø­Ø¨ */
    }
    #btnUp{ grid-area: up; }
    #btnLeft{ grid-area: left; }
    #btnDown{ grid-area: down; }
    #btnRight{ grid-area: right; }
    .mobile-ctrl button{
      padding:18px 0; border-radius:16px; min-width:84px; min-height:84px;
      font-size:32px; font-weight:900;
      touch-action:none;
      position:relative; overflow:hidden;
    }
    .mobile-ctrl button::after{
      content:""; position:absolute; inset:-2px; border-radius:inherit;
      box-shadow:0 0 0 rgba(25,240,214,0); transition: box-shadow .25s ease;
      pointer-events:none;
    }
    .mobile-ctrl button:active::after{
      box-shadow:0 0 30px rgba(25,240,214,.25), inset 0 0 30px rgba(25,240,214,.15);
    }

    @media (max-width:480px){
      .mobile-ctrl{
        grid-template-columns:minmax(88px, 32%) minmax(88px, 32%) minmax(88px, 32%);
        gap:12px;
      }
      .mobile-ctrl button{
        min-width:88px; min-height:88px; font-size:30px; border-radius:16px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <h1>ğŸ¶ğŸ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙˆØ¯Ø© â€” Ù„ÙÙ‘ Ø¹Ù†Ø¯ Ø§Ù„Ø­ÙˆØ§Ù + Ø¬Ø§Ø¦Ø²Ø© ğŸ’© Ã—5</h1>
    <p class="sub">Ù…ØªØ¬Ø§ÙˆØ¨Ø© Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„: Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙˆØ§Ø¶Ø­Ø© Ø¨ÙƒÙ„ Ø§Ù„Ø´Ø§Ø´Ø§ØªØŒ Ø§Ù„Ø£Ø­Ø°ÙŠØ© Ù†Ø§Ø¨Ø¶Ø©ØŒ ÙˆØ¬Ø§Ø¦Ø²Ø© ğŸ’© Ø¨Ø´Ø¹Ø§Ø¹ ØªØ­Ø³Ø¨ Ø®Ù…Ø³ Ø£Ø­Ø°ÙŠØ©.</p>

    <div class="hud" id="hud">
      <div class="stat">Ø§Ù„Ù†ØªÙŠØ¬Ø©: <span id="score" class="v">0</span></div>
      <div class="stat">Ø£ÙƒÙ„Øª: <span id="eaten" class="v">0</span> / <span id="target" class="v">50</span></div>
      <div class="stat">Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <span id="left" class="v">50</span></div>
      <div class="btns">
        <button id="startBtn">Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
        <button id="pauseBtn" class="sec">Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª (P)</button>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="game" width="600" height="600" aria-label="Ù„ÙˆØ­Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©"></canvas>

      <!-- Ø§Ù„ØªÙˆØ³Øª Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© -->
      <div id="toast" class="toast" aria-live="polite" aria-atomic="true"></div>

      <!-- Overlay -->
      <div id="overlay" class="overlay" role="dialog" aria-modal="true" style="display:flex;">
        <div class="card">
          <h2>Ø¬Ø§Ù‡Ø²ØŸ Ø®Ù„ Ù†Ø¨Ù„Ù‘Ø´ ğŸ®</h2>
          <div class="tips">
            <p>Ø±Ø£Ø³ Ø§Ù„Ø¯ÙˆØ¯Ø© ÙƒÙ„Ø¨ ğŸ¶. Ù‡Ø¯ÙÙƒ ØªØ£ÙƒÙ„ <b>50</b> Ø­Ø°Ø§Ø¡. Ø¹Ù†Ø¯Ùƒ Ø¬Ø§Ø¦Ø²Ø© ğŸ’© Ø£ÙƒØ¨Ø± ØªØ·Ù„Ø¹ ÙƒÙ„ ÙƒÙ… Ø­Ø°Ø§Ø¡ ÙˆØªØ­Ø³Ø¨ Ã—5.</p>
            <ul>
              <li>Ø§Ù„ØªØ­ÙƒÙ…: Ø§Ù„Ø£Ø³Ù‡Ù… â¬…ï¸â¬†ï¸â¬‡ï¸â¡ï¸ Ø£Ùˆ WASD</li>
              <li>Ù…ÙˆØ¨Ø§ÙŠÙ„: Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø§Ù„Ø£Ø³ÙÙ„ (ÙŠÙ…ÙŠÙ† = ÙŠÙ…ÙŠÙ† âœ”ï¸)</li>
              <li>Ø²Ø± <b>P</b> Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¤Ù‚Øª</li>
            </ul>
          </div>
          <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px">
            <button id="overlayStartBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
            <button id="overlayHideBtn" class="sec">Ø¥Ø®ÙØ§Ø¡</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Ø£Ø²Ø±Ø§Ø± Ù…ÙˆØ¨Ø§ÙŠÙ„ -->
    <div class="mobile-ctrl" id="mobileCtrl" aria-hidden="false">
      <button id="btnUp"   class="sec" aria-label="ÙÙˆÙ‚">â¬†ï¸</button>
      <button id="btnLeft" class="sec" aria-label="ÙŠØ³Ø§Ø±">â¬…ï¸</button>
      <button id="btnDown" class="sec" aria-label="Ø¬ÙˆÙ‡">â¬‡ï¸</button>
      <button id="btnRight"class="sec" aria-label="ÙŠÙ…ÙŠÙ†">â¡ï¸</button>
    </div>
  </div>

  <script>
    /*********** Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ***********/
    const NAME_TEXT = "Ø¨ÙƒØ±";
    const GRID = 20;                 // Ø´Ø¨ÙƒØ© 20Ã—20 (ÙˆØ§Ø¶Ø­Ø©)
    const BASE_SPEED_MS = 135;
    const SPEED_STEP = 7;
    const TARGET_EATS = 50;
    const MIN_SPEED_MS = 70;

    // Ø¬Ø§Ø¦Ø²Ø© ğŸ’© ÙƒÙ„ ÙƒÙ… Ø­Ø°Ø§Ø¡ØŸ
    const BONUS_EVERY = 7;           // ÙƒÙ„ 7 Ø£Ø­Ø°ÙŠØ© ÙŠØ·Ù„Ø¹ ğŸ’©
    const BONUS_VALUE = 5;           // ÙŠØ­Ø³Ø¨ 5 Ø£Ø­Ø°ÙŠØ©
    const BONUS_EMOJI = "ğŸ’©";

    const BODY_BORDER = getComputedStyle(document.documentElement).getPropertyValue('--snakeBorder').trim();
    const BODY_FILL1  = getComputedStyle(document.documentElement).getPropertyValue('--snakeFill1').trim();
    const BODY_FILL2  = getComputedStyle(document.documentElement).getPropertyValue('--snakeFill2').trim();
    const HEAD_OUTLINE= getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim();
    const WALL_HIT_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim();

    // Ø£Ø­Ø°ÙŠØ© (Ø£ÙˆØ¶Ø­ + Ø³Ù†Ø¶ÙŠÙ Ù†Ø¨Ø¶ Ø¨Ø§Ù„Ø±Ø³Ù…)
    const SHOES = ["ğŸ‘Ÿ","ğŸ‘","ğŸ¥¾","ğŸ‘ ","ğŸ¥¿","ğŸ©°","ğŸ©´","ğŸ›¼"];

    /*********** DOM ***********/
    const wrap = document.getElementById("wrap");
    const hud = document.getElementById("hud");
    const mobileCtrl = document.getElementById("mobileCtrl");
    const canvasWrap = document.getElementById("canvasWrap");
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const eatenEl = document.getElementById("eaten");
    const targetEl = document.getElementById("target");
    const leftEl = document.getElementById("left");
    const overlay = document.getElementById("overlay");
    const overlayStartBtn = document.getElementById("overlayStartBtn");
    const overlayHideBtn = document.getElementById("overlayHideBtn");
    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const toast = document.getElementById("toast");
    targetEl.textContent = TARGET_EATS;

    /*********** Ù‚ÙŠØ§Ø³ ÙˆØ­Ø¬Ù… Ø§Ù„Ø³Ø§Ø­Ø© Ø­Ø³Ø¨ Ø§Ù„Ø´Ø§Ø´Ø© (Ø­ØªÙ‰ ØªØ¨Ù‚Ù‰ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙˆØ§Ø¶Ø­Ø©) ***********/
    function fitCanvasToViewport(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      // Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…ØªØ§Ø­Ø© = Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø´Ø§Ø´Ø© - HUD - Ø£Ø²Ø±Ø§Ø± - Ù‡ÙˆØ§Ù…Ø´ Ø¨Ø³ÙŠØ·Ø©
      const hudH = hud.offsetHeight || 0;
      const ctrlH = mobileCtrl.offsetHeight || 0;
      const margins = 28; // Ù‡Ø§Ù…Ø´ Ù…Ø±ÙŠØ­
      const availH = Math.max(240, window.innerHeight - hudH - ctrlH - margins);

      // Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØ§Ø­ Ø¶Ù…Ù† Ø§Ù„Ù„ÙÙ‘Ø§Ù
      const availW = wrap.clientWidth || window.innerWidth;

      // Ù†Ø¨Ù‚ÙŠ Ø§Ù„Ù„ÙˆØ­Ø© Ù…Ø±Ø¨Ø¹Ø©ØŒ Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ø¹Ø±Ø¶/Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
      const cssSize = Math.max(240, Math.min(availW, availH));
      canvas.style.width = `${cssSize}px`;
      canvas.style.height = `${cssSize}px`;

      // Ø¯Ù‚Ø© ÙØ¹Ù„ÙŠØ©
      const px = Math.floor(cssSize * dpr);
      canvas.width = px;
      canvas.height = px;

      // Ø­Ø¬Ù… Ø§Ù„Ø®Ù„ÙŠØ© Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
      tile = Math.floor(Math.min(canvas.width, canvas.height) / state.cols);
    }
    window.addEventListener("resize", fitCanvasToViewport);

    let tile; // ÙŠÙØ­Ø¯Ù‘ÙØ« Ø¯Ø§Ø®Ù„ fitCanvasToViewport
    let state;

    function defaultState(){
      const cols = GRID, rows = GRID;
      const startX = Math.floor(cols/2), startY = Math.floor(rows/2);

      return {
        cols, rows,
        snake: [{x:startX,y:startY},{x:startX-1,y:startY},{x:startX-2,y:startY}],
        dir:{x:1,y:0}, nextDir:{x:1,y:0},
        food: null,
        bonus: null, // {x,y,createdAt}
        normalSinceBonus: 0,
        grow: 0, // Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù„ÙŠ ØªÙƒØ¨Ø±Ù‡Ø§ Ø§Ù„Ø¯ÙˆØ¯Ø© ØªØ¯Ø±ÙŠØ¬ÙŠÙ‹Ø§
        score:0, eaten:0,
        speedMs:BASE_SPEED_MS,
        running:false, paused:false, gameOver:false, won:false,
        tickHandle:null, lastStepAt:0
      };
    }

    function coordKey(x,y){ return `${x},${y}`; }
    function snakeSet(snake){ const s=new Set(); for(const c of snake){ s.add(coordKey(c.x,c.y)); } return s; }

    function spawnFoodRandom(bannedSet){
      let x,y,tries=0;
      do{ x=Math.floor(Math.random()*state.cols); y=Math.floor(Math.random()*state.rows); tries++; if(tries>500) break; }
      while(bannedSet.has(coordKey(x,y)) || (state.bonus && state.bonus.x===x && state.bonus.y===y));
      const emoji = SHOES[Math.floor(Math.random()*SHOES.length)];
      return {x,y,emoji};
    }

    function spawnBonusRandom(){
      const banned = snakeSet(state.snake);
      if(state.food) banned.add(coordKey(state.food.x, state.food.y));
      let x,y,tries=0;
      do{ x=Math.floor(Math.random()*state.cols); y=Math.floor(Math.random()*state.rows); tries++; if(tries>500) break; }
      while(banned.has(coordKey(x,y)));
      return {x,y,createdAt: performance.now()};
    }

    function startGame(){
      state = defaultState();
      fitCanvasToViewport();
      hideToast(true);
      overlay.style.display = "none";
      scoreEl.textContent = "0";
      eatenEl.textContent = "0";
      leftEl.textContent = TARGET_EATS;
      state.food = spawnFoodRandom(snakeSet(state.snake));
      state.running = true; state.paused = false; state.gameOver = false; state.won = false;
      initAudio();
      scheduleNextTick(true);
      draw();
    }

    function pauseResume(){
      if(!state?.running || state?.gameOver) return;
      state.paused = !state.paused;
      if(!state.paused){ scheduleNextTick(true); resumeAudio(); }
      else { if(state.tickHandle) cancelAnimationFrame(state.tickHandle), state.tickHandle=null; }
      pauseBtn.textContent = state.paused ? "ØªØ§Ø¨Ø¹ Ø§Ù„Ù„Ø¹Ø¨ (P)" : "Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª (P)";
    }

    function scheduleNextTick(reset=false){
      if(reset && state.tickHandle){ cancelAnimationFrame(state.tickHandle); }
      state.lastStepAt = performance.now();
      const step = (t)=>{
        const elapsed = t - state.lastStepAt;
        if(elapsed >= state.speedMs){ stepGame(); state.lastStepAt = t; }
        draw(t);
        if(state.running && !state.paused && !state.gameOver){ state.tickHandle = requestAnimationFrame(step); }
      };
      state.tickHandle = requestAnimationFrame(step);
    }

    function stepGame(){
      if(!state || !state.running || state.paused || state.gameOver) return;

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù„Ø§ ØªØ±Ø¬Ø¹ 180Â°)
      const {x:nx,y:ny} = state.nextDir;
      if(!(nx===-state.dir.x && ny===-state.dir.y)){ state.dir = {x:nx,y:ny}; }

      const head = state.snake[0];

      // Ù„ÙÙ‘ Ø¹Ù†Ø¯ Ø§Ù„Ø­ÙˆØ§Ù (torus wrap)
      let nhx = head.x + state.dir.x;
      let nhy = head.y + state.dir.y;
      nhx = (nhx + state.cols) % state.cols;
      nhy = (nhy + state.rows) % state.rows;

      const newHead = {x: nhx, y: nhy};

      // Ø§ØµØ·Ø¯Ø§Ù… Ø°Ø§ØªÙŠ (ÙŠØ¨Ù‚Ù‰ Ø®Ø³Ø§Ø±Ø©)
      const bodySet = snakeSet(state.snake.slice(0,-1));
      if(bodySet.has(coordKey(newHead.x,newHead.y))){ return loseGame(); }

      // ØªØ­Ø±ÙŠÙƒ
      state.snake.unshift(newHead);

      let ateSomething = false;

      // Ø£ÙƒÙ„ Ø¬Ø§Ø¦Ø²Ø© ğŸ’© ØŸ
      if(state.bonus && newHead.x===state.bonus.x && newHead.y===state.bonus.y){
        // ØªØ²ÙŠØ¯ Ã—5
        state.eaten += BONUS_VALUE;
        state.score += BONUS_VALUE * 10;
        state.grow += BONUS_VALUE;
        ateSomething = true;
        state.bonus = null;
        scoreEl.textContent = state.score;
        eatenEl.textContent = state.eaten;
        leftEl.textContent = Math.max(0, TARGET_EATS - state.eaten);
        showToast("Ø¬Ø§Ø¦Ø²Ø© Ã—5! ğŸ’©");
        // ÙÙˆØ² Ø¥Ø°Ø§ ÙˆØµÙ„ Ø§Ù„Ù‡Ø¯Ù
        if(state.eaten >= TARGET_EATS){ return winGame(); }
      }

      // Ø£ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠØŸ
      if(state.food && newHead.x===state.food.x && newHead.y===state.food.y){
        state.eaten += 1;
        state.score += 10;
        state.grow += 1;
        ateSomething = true;
        scoreEl.textContent = state.score;
        eatenEl.textContent = state.eaten;
        leftEl.textContent = Math.max(0, TARGET_EATS - state.eaten);

        playChomp();
        showToast("Ø¨Ø§Ù„Ø¹Ø§ÙÙŠØ© Ø¨ÙƒÙˆØ±ÙŠ");

        // ØªØ³Ø±ÙŠØ¹ Ø¨Ø³ÙŠØ·
        if(state.eaten % SPEED_STEP === 0 && state.speedMs > MIN_SPEED_MS){ state.speedMs -= 8; }

        // Ø³Ø¨ÙˆÙ† Ø£ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ Ø¬Ø¯ÙŠØ¯
        const occupied = snakeSet(state.snake);
        if(state.bonus) occupied.add(coordKey(state.bonus.x, state.bonus.y));
        state.food = spawnFoodRandom(occupied);

        // Ø¬Ø§Ø¦Ø²Ø© ğŸ’© ÙƒÙ„ BONUS_EVERY Ø£ÙƒÙ„Ø§Øª Ø·Ø¨ÙŠØ¹ÙŠØ©
        state.normalSinceBonus++;
        if(state.normalSinceBonus >= BONUS_EVERY && !state.bonus){
          state.bonus = spawnBonusRandom();
          state.normalSinceBonus = 0;
        }

        // ÙÙˆØ² Ø¥Ø°Ø§ ÙˆØµÙ„ Ø§Ù„Ù‡Ø¯Ù
        if(state.eaten >= TARGET_EATS){ return winGame(); }
      }

      // Ø¥Ø°Ø§ Ù…Ø§ Ø£ÙƒÙ„ Ø´ÙŠØŒ Ù†Ù‚Øµ Ø§Ù„Ø°ÙŠÙ„ Ø¥Ù„Ø§ Ø¥Ø°Ø§ Ø¹Ù†Ø¯Ù‡ Ù†Ù…Ùˆ Ù…ØªØ±Ø§ÙƒÙ…
      if(!ateSomething){
        if(state.grow > 0){ state.grow--; } else { state.snake.pop(); }
      }
    }

    function winGame(){
      state.won = true; state.gameOver = true; state.running = false;
      if(state.tickHandle){ cancelAnimationFrame(state.tickHandle); state.tickHandle=null; }
      playBurpLaugh();
      showEndOverlay(true, state.eaten);
      flashOverlayTint(0.08);
    }
    function loseGame(){
      state.gameOver = true; state.running = false;
      if(state.tickHandle){ cancelAnimationFrame(state.tickHandle); state.tickHandle=null; }
      showEndOverlay(false, state.eaten);
      flashOverlayTint(0.12);
    }

    function showEndOverlay(won, count){
      overlay.innerHTML = `
        <div class="card">
          <h2>${won ? "ğŸ‰ ÙÙˆØ²" : "ğŸ’¥ Ø®Ø³Ø§Ø±Ø©"}</h2>
          <p class="tips" style="text-align:center">
            ${won
              ? `<b>Ø¹ÙÙŠÙ‡ Ø¹Ù„ÙŠÙƒ Ø¨ÙƒÙˆØ±ÙŠ!</b> Ø£ÙƒÙ„Øª Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø­Ø°ÙŠØ©: <b>${count}</b>`
              : `<b>Ø·ÙŠØ­ Ø§Ù„Ù„Ù‡ Ø­Ø¶Ù‘Ùƒ Ø¨ÙƒØ±!</b> Ù…Ø§ Ø£ÙƒÙ„Øª Ø¨Ø³ <b>${count}</b> Ù…Ù† ${TARGET_EATS}`
            }
          </p>
          <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px">
            <button id="overlayRestartBtn">Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            <button id="overlayHideBtn2" class="sec">Ø¥Ø®ÙØ§Ø¡</button>
          </div>
        </div>`;
      overlay.style.display = "flex";
      document.getElementById("overlayRestartBtn")?.addEventListener("click", startGame);
      document.getElementById("overlayHideBtn2")?.addEventListener("click", ()=> overlay.style.display="none");
    }

    function flashOverlayTint(alpha=0.12){
      // ØªÙ„ÙˆÙŠÙ† Ø¨Ø³ÙŠØ· ÙÙˆØ± Ø§Ù„Ø®Ø³Ø§Ø±Ø©/Ø§Ù„ÙÙˆØ²
      const orig = ctx.fillStyle;
      ctx.fillStyle = WALL_HIT_COLOR;
      ctx.globalAlpha = alpha;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha = 1; ctx.fillStyle = orig;
    }

    /*********** Ø§Ù„Ø±Ø³Ù… ***********/
    function draw(t=performance.now()){
      if(!state) return;
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);
      drawGrid();
      if(state.food)  drawFood(state.food, t);
      if(state.bonus) drawBonus(state.bonus, t);
      drawSnake();
    }

    function drawGrid(){
      ctx.save();
      ctx.fillStyle = "#0f1216";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = "#111820"; ctx.lineWidth = Math.max(1, tile*.03); ctx.globalAlpha=.5;
      for(let i=0;i<=state.cols;i++){ 
        ctx.beginPath(); ctx.moveTo(i*tile,0); ctx.lineTo(i*tile,state.rows*tile); ctx.stroke(); 
      }
      for (let j = 0; j <= state.rows; j++) {
        ctx.beginPath(); ctx.moveTo(0,j*tile); ctx.lineTo(state.cols*tile,j*tile); ctx.stroke();
      }
      ctx.globalAlpha=1; ctx.restore();
    }

    // Ø£Ø­Ø°ÙŠØ©: Ø£ÙƒØ¨Ø± + Ù†Ø¨Ø¶ Ø®ÙÙŠÙ
    function drawFood(food, t){
      const {x,y,emoji} = food;
      const cx = x*tile + tile/2;
      const cy = y*tile + tile/2;
      ctx.save();
      const pulse = 1 + 0.05 * Math.sin((t/420) + (x*7 + y*11));
      const fontSize = Math.floor(tile * 1.88 * pulse); // Ø¶Ø¹Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© + Ù†Ø¨Ø¶
      ctx.font = `${fontSize}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,.5)"; ctx.shadowBlur = tile*0.18;
      ctx.fillText(emoji, cx, cy+1);
      ctx.restore();
    }

    // Ø¬Ø§Ø¦Ø²Ø© ğŸ’© Ù…Ø¹ Ø´Ø¹Ø§Ø¹/Ù‡Ø§Ù„Ø© Ù†Ø§Ø¨Ø¶Ø©
    function drawBonus(bonus, t){
      const {x,y,createdAt} = bonus;
      const cx = x*tile + tile/2;
      const cy = y*tile + tile/2;
      const age = (t - createdAt) / 1000;

      // Ù‡Ø§Ù„Ø© Ù†Ø§Ø¨Ø¶Ø©
      ctx.save();
      const baseR = tile * 0.95;
      const r = baseR + (Math.sin(t/250) * tile * 0.12);
      const grd = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r);
      grd.addColorStop(0, "rgba(255, 210, 0, 0.25)");
      grd.addColorStop(1, "rgba(255, 210, 0, 0.01)");
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // ğŸ’© Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ø£ÙƒÙ„ Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠ
      ctx.save();
      const wobble = 1 + 0.06 * Math.sin((t/360) + age);
      const fontSize = Math.floor(tile * 2.1 * wobble);
      ctx.font = `${fontSize}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(255, 210, 0, .6)";
      ctx.shadowBlur = tile*0.22;
      ctx.fillText(BONUS_EMOJI, cx, cy+1);
      ctx.restore();
    }

    // Ø¬Ø³Ù… Ø§Ù„Ø¯ÙˆØ¯Ø© (Ø´ÙƒÙ„ Ø­ÙŠÙ‘Ø© ÙˆØ§Ø¶Ø­) + Ø±Ø£Ø³ ÙƒÙ„Ø¨
    function drawSnake(){
      for(let i=state.snake.length-1;i>=1;i--){
        const seg = state.snake[i];
        const x = seg.x*tile, y = seg.y*tile;

        ctx.save();
        const r = Math.max(4, Math.floor(tile*0.28));
        ctx.lineWidth = Math.max(2, tile*0.08);
        roundRect(ctx, x+1, y+1, tile-2, tile-2, r);
        ctx.strokeStyle = BODY_BORDER; ctx.stroke();

        const g = ctx.createLinearGradient(x, y, x, y+tile);
        g.addColorStop(0, BODY_FILL1); g.addColorStop(1, BODY_FILL2);
        ctx.fillStyle = g;
        roundRect(ctx, x+2, y+2, tile-4, tile-4, r*0.8);
        ctx.fill();

        // Ø¨Ø·Ù† Ø®ÙÙŠÙ
        ctx.globalAlpha = 0.12; ctx.fillStyle = "#ffffff";
        ctx.fillRect(x+tile*0.18, y+tile*0.42, tile*0.64, tile*0.16);
        ctx.globalAlpha = 1;

        // Ù‚Ø´ÙˆØ± Ø®ÙÙŠÙØ©
        ctx.save();
        ctx.beginPath(); roundRect(ctx, x+2, y+2, tile-4, tile-4, r*0.8); ctx.clip();
        ctx.globalAlpha = 0.08; ctx.fillStyle = "#053d33";
        const step = tile*0.33;
        for(let yy=y+step*0.6; yy<y+tile; yy+=step){
          for(let xx=x+step*0.6; xx<x+tile; xx+=step){
            ctx.beginPath(); ctx.arc(xx, yy, step*0.38, 0, Math.PI*2); ctx.fill();
          }
        }
        ctx.restore();

        if(i % 2 === 0){
          ctx.save();
          ctx.fillStyle = "#073f37";
          ctx.font = `${Math.floor(tile*0.45)}px "Noto Naskh Arabic","Segoe UI",Arial`;
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText(NAME_TEXT, x + tile/2, y + tile/2 + 1);
          ctx.restore();
        }
        ctx.restore();
      }

      // Ø§Ù„Ø±Ø£Ø³ (ÙƒÙ„Ø¨) Ù…Ø¹ ØªØ¯ÙˆÙŠØ±
      const head = state.snake[0];
      const hx = head.x*tile, hy = head.y*tile;

      ctx.save();
      ctx.lineWidth = Math.max(2, tile*0.1);
      ctx.strokeStyle = HEAD_OUTLINE;
      ctx.fillStyle = "#15242a";
      roundRect(ctx, hx+1, hy+1, tile-2, tile-2, Math.max(6, tile*0.28));
      ctx.fill(); ctx.stroke();
      ctx.restore();

      const dir = state.dir;
      const cx = hx + tile/2, cy = hy + tile/2;
      const angle = dir.x===1?0 : dir.x===-1?Math.PI : dir.y===1?Math.PI/2 : -Math.PI/2;

      ctx.save();
      ctx.translate(cx, cy); ctx.rotate(angle);
      const fontSize = Math.floor(tile*0.8);
      ctx.font = `${fontSize}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji"`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText("ğŸ¶", 0, 1);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    /*********** Ø§Ù„ØªÙˆØ³Øª ***********/
    let toastTimer=null;
    function showToast(msg){
      toast.textContent = msg; toast.classList.add("show");
      if(toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> toast.classList.remove("show"), 1000);
    }
    function hideToast(immediate=false){
      if(immediate){
        toast.classList.remove("show");
        if(toastTimer){ clearTimeout(toastTimer); toastTimer=null; }
      } else { toast.classList.remove("show"); }
    }

    /*********** Ø§Ù„ØµÙˆØªÙŠØ§Øª ***********/
    let audioCtx=null;
    function initAudio(){ if(!audioCtx){ const AC = window.AudioContext||window.webkitAudioContext; audioCtx=new AC(); } resumeAudio(); }
    function resumeAudio(){ if(audioCtx && audioCtx.state==="suspended") audioCtx.resume(); }
    function playChomp(){
      if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
      osc.type="square"; osc.frequency.setValueAtTime(620,t0); osc.frequency.exponentialRampToValueAtTime(180,t0+0.12);
      gain.gain.setValueAtTime(0.0001,t0); gain.gain.exponentialRampToValueAtTime(0.3,t0+0.02); gain.gain.exponentialRampToValueAtTime(0.0001,t0+0.14);
      osc.connect(gain).connect(audioCtx.destination); osc.start(t0); osc.stop(t0+0.16);
    }
    function playBurpLaugh(){
      if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const burpOsc = audioCtx.createOscillator(); const burpGain = audioCtx.createGain();
      burpOsc.type="sine"; burpOsc.frequency.setValueAtTime(160,t0); burpOsc.frequency.exponentialRampToValueAtTime(70,t0+0.55);
      burpGain.gain.setValueAtTime(0.001,t0); burpGain.gain.exponentialRampToValueAtTime(0.45,t0+0.08); burpGain.gain.exponentialRampToValueAtTime(0.0001,t0+0.6);
      burpOsc.connect(burpGain).connect(audioCtx.destination); burpOsc.start(t0); burpOsc.stop(t0+0.62);
      for(let i=0;i<3;i++){
        const start = t0 + 0.65 + i*0.12;
        const laughOsc = audioCtx.createOscillator(); const laughGain = audioCtx.createGain();
        laughOsc.type="triangle"; laughOsc.frequency.setValueAtTime(320 + i*20, start);
        laughGain.gain.setValueAtTime(0.001,start); laughGain.gain.exponentialRampToValueAtTime(0.25,start+0.03); laughGain.gain.exponentialRampToValueAtTime(0.0001,start+0.09);
        laughOsc.connect(laughGain).connect(audioCtx.destination); laughOsc.start(start); laughOsc.stop(start+0.11);
      }
    }

    /*********** Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ***********/
    function setDir(dx,dy){
      if(state && (dx !== -state.dir.x || dy !== -state.dir.y)){ state.nextDir = {x:dx, y:dy}; }
    }

    // ÙƒÙŠØ¨ÙˆØ±Ø¯
    window.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if(["arrowup","w"].includes(k)) { e.preventDefault(); setDir(0,-1); }
      else if(["arrowdown","s"].includes(k)) { e.preventDefault(); setDir(0, 1); }
      else if(["arrowleft","a"].includes(k)) { e.preventDefault(); setDir(-1,0); }
      else if(["arrowright","d"].includes(k)) { e.preventDefault(); setDir(1,0); }
      else if(k==="p"){ pauseResume(); }
      else if(k==="enter" && overlay.style.display!=="none"){ startGame(); }
    }, {passive:false});

    // HUD
    startBtn.addEventListener("click", startGame);
    pauseBtn.addEventListener("click", pauseResume);

    // Overlay
    overlayStartBtn.addEventListener("click", startGame);
    overlayHideBtn.addEventListener("click", ()=> overlay.style.display="none");

    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ â€” Ø«Ù„Ø§Ø« Ø£Ø­Ø¯Ø§Ø« Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø¹Ù…Ù„ Ø¨ÙƒÙ„ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©
    function bindDirBtn(el, dx, dy){
      const handler = (e)=>{ e.preventDefault(); setDir(dx,dy); };
      el.addEventListener("pointerdown", handler, {passive:false});
      el.addEventListener("touchstart", handler, {passive:false});
      el.addEventListener("click", handler, {passive:false});
    }
    bindDirBtn(document.getElementById("btnUp"),    0,-1);
    bindDirBtn(document.getElementById("btnLeft"), -1, 0);
    bindDirBtn(document.getElementById("btnDown"),  0, 1);
    bindDirBtn(document.getElementById("btnRight"), 1, 0);

    // Ø£ÙˆÙ„ ØªØ´ØºÙŠÙ„: Ø§Ø¶Ø¨Ø· Ø§Ù„Ø­Ø¬Ù… ÙˆÙˆØ±Ù‘ÙŠ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª
    window.addEventListener("load", fitCanvasToViewport);
    overlay.style.display = "flex";
  </script>
</body>
</html>
