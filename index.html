<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙˆØ¯Ø© â€” Ù†Ø³Ø®Ø© Ø¨ÙƒØ± ÙˆØ§Ù„Ø§Ø­Ø°ÙŠØ© ğŸ¶</title>
  <style>
    :root{
      --bg:#14161a;
      --panel:#1c2026;
      --accent:#00d0b0;
      --danger:#ff4d4f;
      --text:#e8ecef;
      --btnGrad1:#e60012; /* Mario Red */
      --btnGrad2:#b3000e;
      --btnBorder:#5c0007;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(circle at center, #2b3340 0, #000 100%);
      color:var(--text); font-family:"Segoe UI", Tahoma, Arial, system-ui;
      display:flex; align-items:center; justify-content:center; min-height:100vh; padding:12px;
      overflow:hidden; touch-action:none;
    }
    .wrap{ width:min(95vw, 680px); margin:auto; display:flex; flex-direction:column; align-items:center;}
    h1{ margin:0 0 10px; font-size:clamp(18px, 4.5vw, 24px); text-shadow:0 2px 4px #000; color:#fff;}

    .hud{
      width:100%; display:flex; gap:10px; align-items:center; justify-content:space-between;
      background:#222; border:2px solid #444; border-radius:12px; padding:8px 12px; margin-bottom:10px;
      box-shadow:0 4px 10px rgba(0,0,0,0.5);
    }
    .stat{font-weight:bold; font-size:14px; color:#ddd;}
    .v{color:#ffcd00; font-size:16px;} /* Mario Coin Color */
    
    .canvas-wrap{
      position:relative; border-radius:12px; overflow:hidden;
      border:4px solid #fff; box-shadow:0 10px 30px rgba(0,0,0,0.6);
      background:#5c94fc; /* Mario Sky Blue */
    }
    canvas{
      display:block; width:100%; height:auto;
      background:repeating-linear-gradient(0deg, #5c94fc 0 20px, #6ca0fc 20px 40px);
    }

    /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… */
    .mobile-ctrl{
      direction:ltr; margin-top:15px; display:grid;
      grid-template-columns:repeat(3, 70px); grid-template-rows:repeat(2, 60px);
      gap:8px; justify-content:center;
    }
    .mobile-ctrl button{
      background:#333; color:#fff; border:2px solid #555; border-radius:10px;
      font-size:24px; cursor:pointer; touch-action:manipulation;
      box-shadow:0 4px 0 #111; transition:transform 0.1s;
    }
    .mobile-ctrl button:active{ transform:translateY(4px); box-shadow:0 0 0 #111; background:#444;}
    #btnUp{ grid-column:2; grid-row:1; background:var(--btnGrad1); border-color:var(--btnBorder); }
    #btnLeft{ grid-column:1; grid-row:2; }
    #btnDown{ grid-column:2; grid-row:2; }
    #btnRight{ grid-column:3; grid-row:2; }

    /* Overlay */
    .overlay{
      position:absolute; inset:0; background:rgba(0,0,0,0.85);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      text-align:center; padding:20px; z-index:10;
    }
    .card h2{ color:#ffcd00; text-shadow:2px 2px 0 #b3000e; font-size:32px; margin:0 0 10px;}
    .start-btn{
      background:linear-gradient(#00d028, #00941c); color:#fff; border:2px solid #005c11;
      padding:12px 30px; font-size:20px; font-weight:bold; border-radius:50px;
      cursor:pointer; box-shadow:0 6px 0 #004d0e; text-shadow:0 1px 2px rgba(0,0,0,0.5);
      transition:transform 0.1s;
    }
    .start-btn:active{ transform:translateY(6px); box-shadow:0 0 0; }
    
    .toast{
      position:absolute; top:20px; left:50%; transform:translateX(-50%) translateY(-50px);
      background:rgba(0,0,0,0.8); color:#fff; padding:8px 16px; border-radius:20px;
      font-weight:bold; transition:0.3s; opacity:0; pointer-events:none; border:1px solid #fff;
    }
    .toast.show{ transform:translateX(-50%) translateY(0); opacity:1; }

  </style>
</head>
<body>

<div class="wrap">
  <h1>ğŸ¶ Ø³ÙˆØ¨Ø± Ø¨ÙƒØ± Ù…Ø§Ø±ÙŠÙˆ ğŸ</h1>
  
  <div class="hud">
    <div class="stat">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="score" class="v">0</span></div>
    <div class="stat">Ø§Ù„Ø£Ø­Ø°ÙŠØ©: <span id="eaten" class="v">0</span></div>
    <div class="stat">Ø§Ù„Ù‡Ø¯Ù: <span id="target" class="v">50</span></div>
    <button id="pauseBtn" style="padding:5px 10px; font-size:12px; cursor:pointer;">II</button>
  </div>

  <div class="canvas-wrap">
    <canvas id="game" width="600" height="600"></canvas>
    
    <div id="toast" class="toast"></div>

    <div id="overlay" class="overlay">
      <div class="card">
        <h2>Ø¬Ø§Ù‡Ø²ØŸ</h2>
        <p style="color:#ddd; margin-bottom:20px; line-height:1.6;">
          Ø§Ø¬Ù…Ø¹ 50 Ø­Ø°Ø§Ø¡ ğŸ‘Ÿ<br>
          Ø§Ù†ØªØ¨Ù‡ Ù…Ù† Ø§Ù„Ù€ ğŸ’© ÙŠØ¸Ù‡Ø± ÙˆÙŠØ®ØªÙÙŠ Ø¨Ø³Ø±Ø¹Ø©!<br>
          Ø§Ø³ØªÙ…ØªØ¹ Ø¨Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ù…Ø§Ø±ÙŠÙˆ ğŸ¶
        </p>
        <button id="startBtn" class="start-btn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
      </div>
    </div>
  </div>

  <div class="mobile-ctrl">
    <button id="btnUp">â¬†ï¸</button>
    <button id="btnLeft">â¬…ï¸</button>
    <button id="btnDown">â¬‡ï¸</button>
    <button id="btnRight">â¡ï¸</button>
  </div>
</div>

<script>
  /********* Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© *********/
  const NAME = "Ø¨ÙƒØ±";
  const GRID = 20; 
  const TARGET = 50;
  const BONUS_LIFETIME = 5000; // 5 Ø«ÙˆØ§Ù†ÙŠ Ù„Ù„Ø¬Ø§Ø¦Ø²Ø©
  
  // Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø­ÙŠØ©
  const SNAKE_COLOR_1 = "#ff9800"; // Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ ÙƒÙ„Ø¨ÙŠ
  const SNAKE_COLOR_2 = "#795548"; // Ø¨Ù†ÙŠ

  const SHOES = ["ğŸ‘Ÿ","ğŸ‘","ğŸ¥¾","ğŸ‘ ","ğŸ¥¿","ğŸ©´"];

  // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
  let canvas, ctx, tile;
  let state = {
    snake: [], dir: {x:1, y:0}, nextDir: {x:1, y:0},
    food: null, bonus: null,
    score: 0, eaten: 0,
    lastTick: 0, speed: 130,
    running: false, paused: false,
    mouthOpen: false, // Ù„Ù„ØªØ­ÙƒÙ… Ø¨ÙÙ… Ø§Ù„ÙƒÙ„Ø¨
    wavyOffset: 0 // Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ù…Ù„ØªÙˆÙŠØ©
  };

  /********* Ù†Ø¸Ø§Ù… Ø§Ù„ØµÙˆØª (Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ù…Ø§Ø±ÙŠÙˆ) *********/
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let actx;

  function initAudio(){ if(!actx) actx = new AudioContext(); if(actx.state==='suspended') actx.resume(); }

  // Ù…ÙˆÙ„Ø¯ Ù†ØºÙ…Ø§Øª Ø¨Ø³ÙŠØ· (Oscillator)
  function beep(freq, duration, type="square", vol=0.1, time=0) {
    if(!actx) return;
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, actx.currentTime + time);
    gain.gain.setValueAtTime(vol, actx.currentTime + time);
    gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + time + duration);
    osc.connect(gain); gain.connect(actx.destination);
    osc.start(actx.currentTime + time);
    osc.stop(actx.currentTime + time + duration);
  }

  // Ù†ÙˆØªØ§Øª Ù…Ø§Ø±ÙŠÙˆ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØ©
  function playMarioStart() {
    initAudio();
    const t = 0;
    // Intro
    [660, 660, 660, 510, 660, 770, 380].forEach((f, i) => {
      let time = i < 3 ? i*0.15 : i===3 ? 0.45 : i===4 ? 0.6 : i===5 ? 0.9 : 1.2;
      beep(f, 0.1, "square", 0.1, time);
    });
    // Bass line start
    setTimeout(() => {
        // Theme simplified
        [523, 392, 330, 440, 493, 466, 440].forEach((f, i) => beep(f, 0.1, "triangle", 0.08, i*0.2));
    }, 1500);
  }

  function playMarioDeath() {
    initAudio();
    // Death sound
    [1000, 700, 500].forEach((f,i) => beep(f, 0.08, "square", 0.15, i*0.1));
    setTimeout(() => beep(300, 0.4, "sawtooth", 0.2, 0), 400);
  }

  function playVictorySound() {
    initAudio();
    // Level Completeish
    [523, 659, 783, 1046, 783, 1046].forEach((f, i) => beep(f, 0.1, "square", 0.1, i*0.12));
  }

  function playBark() {
    initAudio();
    if(!actx) return;
    // Ù…Ø­Ø§ÙƒØ§Ø© Ù†Ø¨Ø§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¶ÙˆØ¶Ø§Ø¡ ÙˆÙ…ÙˆØ¬Ø© Ù…Ù†Ø®ÙØ¶Ø©
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(300, actx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(50, actx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.2, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.15);
    osc.connect(gain); gain.connect(actx.destination);
    osc.start(); osc.stop(actx.currentTime + 0.16);
  }

  /********* Ø§Ù„Ù…Ø­Ø±Ùƒ *********/
  function init() {
    canvas = document.getElementById("game");
    ctx = canvas.getContext("2d");
    resize();
    window.addEventListener("resize", resize);
    
    // Controls
    document.addEventListener("keydown", e => {
      if(["ArrowUp","w"].includes(e.key)) setDir(0,-1);
      if(["ArrowDown","s"].includes(e.key)) setDir(0,1);
      if(["ArrowLeft","a"].includes(e.key)) setDir(-1,0);
      if(["ArrowRight","d"].includes(e.key)) setDir(1,0);
    });
    
    // Mobile Buttons
    bindBtn("btnUp", 0, -1);
    bindBtn("btnDown", 0, 1);
    bindBtn("btnLeft", -1, 0);
    bindBtn("btnRight", 1, 0);

    document.getElementById("startBtn").onclick = startGame;
    document.getElementById("pauseBtn").onclick = togglePause;
  }

  function resize() {
    const size = Math.min(window.innerWidth - 30, window.innerHeight - 250, 600);
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    canvas.width = size; canvas.height = size;
    tile = size / GRID;
    draw();
  }

  function bindBtn(id, x, y) {
    const btn = document.getElementById(id);
    const fn = (e) => { e.preventDefault(); setDir(x,y); };
    btn.addEventListener("touchstart", fn);
    btn.addEventListener("mousedown", fn);
  }

  function setDir(x, y) {
    if(state.dir.x !== -x && state.dir.y !== -y) state.nextDir = {x,y};
  }

  function startGame() {
    document.getElementById("overlay").style.display = "none";
    initAudio();
    playMarioStart(); // Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©

    // Reset State
    state.snake = [{x:10, y:10}, {x:9, y:10}, {x:8, y:10}];
    state.dir = {x:1, y:0}; state.nextDir = {x:1, y:0};
    state.score = 0; state.eaten = 0; state.speed = 130;
    state.bonus = null;
    state.running = true; state.paused = false;
    spawnFood();
    
    updateUI();
    requestAnimationFrame(loop);
  }

  function togglePause() {
    if(!state.running) return;
    state.paused = !state.paused;
    if(!state.paused) requestAnimationFrame(loop);
  }

  function spawnFood() {
    let valid = false, x, y;
    while(!valid) {
      x = Math.floor(Math.random() * GRID);
      y = Math.floor(Math.random() * GRID);
      valid = !state.snake.some(s => s.x === x && s.y === y);
    }
    state.food = {x, y, type: SHOES[Math.floor(Math.random()*SHOES.length)]};
  }

  function spawnBonus() {
    let valid = false, x, y;
    while(!valid) {
      x = Math.floor(Math.random() * GRID);
      y = Math.floor(Math.random() * GRID);
      // ØªØ£ÙƒØ¯ Ù„Ø§ ÙŠÙƒÙˆÙ† ÙÙˆÙ‚ Ø§Ù„Ø­ÙŠØ© ÙˆÙ„Ø§ ÙÙˆÙ‚ Ø§Ù„Ø£ÙƒÙ„
      valid = !state.snake.some(s => s.x === x && s.y === y) && (state.food.x !== x || state.food.y !== y);
    }
    // spawnTime Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù€ 5 Ø«ÙˆØ§Ù†ÙŠ
    state.bonus = {x, y, spawnTime: performance.now()};
  }

  function loop(now) {
    if(!state.running) return;
    if(state.paused) return;

    // Logic Timer
    if(now - state.lastTick > state.speed) {
      updateLogic();
      state.lastTick = now;
    }

    // Bonus Expiration Check (6 Seconds)
    if(state.bonus && (now - state.bonus.spawnTime > BONUS_LIFETIME)) {
      state.bonus = null; // Ø§Ø®ØªÙØ§Ø¡ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©
    }

    draw(now);
    requestAnimationFrame(loop);
  }

  function updateLogic() {
    state.dir = state.nextDir;
    
    // ØªØ­Ø±ÙŠÙƒ Ø§Ù„ÙÙ…
    state.mouthOpen = !state.mouthOpen;

    const head = state.snake[0];
    let nx = (head.x + state.dir.x + GRID) % GRID;
    let ny = (head.y + state.dir.y + GRID) % GRID;

    // Check collision (Body)
    if(state.snake.some((s,i) => i !== state.snake.length-1 && s.x === nx && s.y === ny)) {
      gameOver();
      return;
    }

    const newHead = {x: nx, y: ny};
    state.snake.unshift(newHead);

    let ate = false;

    // Eat Food (Shoe)
    if(state.food && nx === state.food.x && ny === state.food.y) {
      state.score += 10;
      state.eaten++;
      playBark(); // ØµÙˆØª Ø§Ù„Ù†Ø¨Ø§Ø­
      showToast("ğŸ‘Ÿ Ø¨Ø§Ù„Ø¹Ø§Ø§Ø§Ø§ÙÙŠØ© Ø¨ÙƒÙˆØ±ÙŠ!");
      spawnFood();
      ate = true;
      
      // ÙØ±ØµØ© Ø¸Ù‡ÙˆØ± Ø¬Ø§Ø¦Ø²Ø© ÙƒÙ„ 4 Ø£ÙƒÙ„Ø§Øª Ù…Ø«Ù„Ø§Ù‹
      if(state.eaten % 4 === 0) spawnBonus();
      
      // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø±Ø¹Ø©
      if(state.eaten % 5 === 0 && state.speed > 60) state.speed -= 5;
    }

    // Eat Bonus (Poop)
    else if(state.bonus && nx === state.bonus.x && ny === state.bonus.y) {
      state.score += 50;
      state.eaten += 5; // ØªØ­Ø³Ø¨ ÙƒÙ€ 5 Ø£Ø­Ø°ÙŠØ©
      playVictorySound(); // Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø§Ù†ØªØµØ§Ø±
      showToast("ğŸ’© +5 Ø£Ø­Ø°ÙŠØ©!");
      state.bonus = null;
      ate = true;
    }

    if(!ate) state.snake.pop();

    if(state.eaten >= TARGET) win();
    updateUI();
  }

  function draw(time) {
    // Clear
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // Grid (Light)
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 1;
    for(let i=0; i<=GRID; i++) {
      ctx.beginPath(); ctx.moveTo(i*tile,0); ctx.lineTo(i*tile,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,i*tile); ctx.lineTo(canvas.width,i*tile); ctx.stroke();
    }

    // Draw Food (Shoes) - Pulsing
    if(state.food) {
      const pulse = 1 + Math.sin(time * 0.01) * 0.1;
      ctx.font = `${tile * 1.2 * pulse}px Arial`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(state.food.type, (state.food.x+0.5)*tile, (state.food.y+0.55)*tile);
    }

    // Draw Bonus (Poop) - Fast Pulse
    if(state.bonus) {
      const fastPulse = 1 + Math.sin(time * 0.02) * 0.2; // Ù†Ø¨Ø¶ Ø³Ø±ÙŠØ¹
      // Ù‡Ø§Ù„Ø© Ù…Ù‚Ø¯Ø³Ø©
      ctx.fillStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(time*0.03)*0.4})`;
      ctx.beginPath();
      ctx.arc((state.bonus.x+0.5)*tile, (state.bonus.y+0.5)*tile, tile*0.6, 0, Math.PI*2);
      ctx.fill();
      
      ctx.font = `${tile * 1.3 * fastPulse}px Arial`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText("ğŸ’©", (state.bonus.x+0.5)*tile, (state.bonus.y+0.6)*tile);
      
      // Ø´Ø±ÙŠØ· ÙˆÙ‚Øª ØµØºÙŠØ± ÙÙˆÙ‚Ù‡Ø§
      const timeLeft = 1 - (time - state.bonus.spawnTime) / BONUS_LIFETIME;
      ctx.fillStyle = "red";
      ctx.fillRect(state.bonus.x*tile, state.bonus.y*tile, tile * timeLeft, 4);
    }

    // Draw Snake
    drawDogSnake(time);
  }

  function drawDogSnake(time) {
    // Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ù…Ù„ØªÙˆÙŠ
    for(let i = state.snake.length - 1; i >= 0; i--) {
      const seg = state.snake[i];
      const cx = (seg.x + 0.5) * tile;
      const cy = (seg.y + 0.5) * tile;

      // ØªØ£Ø«ÙŠØ± Ø§Ù„ØªÙ…Ø§ÙŠÙ„ (Wavy) - Ù„Ø§ Ù†ØºÙŠØ± Ø§Ù„Ù…Ù†Ø·Ù‚ØŒ Ù†ØºÙŠØ± Ø§Ù„Ø±Ø³Ù… ÙÙ‚Ø·
      // Ø§Ù„Ù…ÙˆØ¬Ø© ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø²Ù…Ù† (time) ÙˆØªØ±ØªÙŠØ¨ Ø§Ù„Ù‚Ø·Ø¹Ø© (i)
      const waveX = (i===0) ? 0 : Math.sin(time * 0.01 + i * 0.5) * (tile * 0.1);
      const waveY = (i===0) ? 0 : Math.cos(time * 0.01 + i * 0.5) * (tile * 0.1);

      const drawX = cx + waveX;
      const drawY = cy + waveY;

      ctx.save();
      ctx.translate(drawX, drawY);

      if (i === 0) {
        // --- Ø±Ø³Ù… Ø±Ø£Ø³ Ø§Ù„ÙƒÙ„Ø¨ (ÙƒØ¨ÙŠØ± 2x) ---
        // Ù†Ø­Ø¯Ø¯ Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø­Ø³Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        let angle = 0;
        if(state.dir.x===1) angle=0;
        else if(state.dir.x===-1) angle=Math.PI;
        else if(state.dir.y===1) angle=Math.PI/2;
        else if(state.dir.y===-1) angle=-Math.PI/2;
        
        ctx.rotate(angle);
        const headSize = tile * 1.8; // Ø­Ø¬Ù… Ù…Ø¶Ø§Ø¹Ù ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹
        
        // Ø±Ø³Ù… Ø§Ù„Ø±Ø£Ø³
        ctx.fillStyle = "#D2691E"; // Ù„ÙˆÙ† Ø§Ù„ÙƒÙ„Ø¨
        // Ø§Ù„Ø¬Ù…Ø¬Ù…Ø©
        ctx.beginPath();
        ctx.ellipse(-headSize*0.2, 0, headSize*0.4, headSize*0.35, 0, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        
        // Ø§Ù„Ø£Ø°Ù†
        ctx.fillStyle = "#5D4037";
        ctx.beginPath();
        ctx.ellipse(-headSize*0.4, -headSize*0.3, headSize*0.15, headSize*0.25, -0.5, 0, Math.PI*2); // Ø£Ø°Ù† ÙŠØ³Ø§Ø±
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(-headSize*0.4, headSize*0.3, headSize*0.15, headSize*0.25, 0.5, 0, Math.PI*2); // Ø£Ø°Ù† ÙŠÙ…ÙŠÙ†
        ctx.fill();

        // Ø§Ù„ÙÙ… Ø§Ù„Ù…ØªØ­Ø±Ùƒ (Snout)
        ctx.fillStyle = "#FFCC80";
        const jawOpen = state.mouthOpen ? headSize*0.15 : 0;
        
        // Ø§Ù„ÙÙƒ Ø§Ù„Ø¹Ù„ÙˆÙŠ
        ctx.beginPath();
        ctx.roundRect(0, -headSize*0.2, headSize*0.4, headSize*0.4, 10);
        ctx.fill();
        // Ø§Ù„Ø£Ù†Ù
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(headSize*0.35, -headSize*0.1, headSize*0.06, 0, Math.PI*2); ctx.fill();
        // Ø§Ù„Ø¹ÙŠÙ†
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(-headSize*0.1, -headSize*0.15, headSize*0.08, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(-headSize*0.08, -headSize*0.15, headSize*0.03, 0, Math.PI*2); ctx.fill();

        // Ø§Ù„ÙÙƒ Ø§Ù„Ø³ÙÙ„ÙŠ (ÙŠØªØ­Ø±Ùƒ)
        ctx.fillStyle = "#D2691E";
        ctx.beginPath();
        ctx.roundRect(0, headSize*0.05 + jawOpen, headSize*0.3, headSize*0.15, 5);
        ctx.fill(); ctx.stroke();

      } else if (i === state.snake.length - 1) {
        // --- Ø±Ø³Ù… Ø§Ù„Ø°ÙŠÙ„ (Ø´Ø¹Ø±) ---
        // Ù†Ø­Ø¯Ø¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„ØªÙŠ Ù‚Ø¨Ù„Ù‡Ø§
        const prev = state.snake[i-1];
        let dx = prev.x - seg.x;
        let dy = prev.y - seg.y;
        // ØªØµØ­ÙŠØ­ Ø§Ù„Ø§Ù„ØªÙØ§Ù
        if(dx > 1) dx = -1; if(dx < -1) dx = 1;
        if(dy > 1) dy = -1; if(dy < -1) dy = 1;
        const angle = Math.atan2(dy, dx);
        
        ctx.rotate(angle);
        ctx.fillStyle = SNAKE_COLOR_2;
        ctx.beginPath();
        ctx.moveTo(0, 0); // Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¬Ø³Ù…
        ctx.quadraticCurveTo(-tile, -tile/2, -tile*1.2, 0); // Ø·Ø±Ù Ø§Ù„Ø°ÙŠÙ„
        ctx.quadraticCurveTo(-tile, tile/2, 0, 0);
        ctx.fill();

      } else {
        // --- Ø±Ø³Ù… Ø§Ù„Ø¬Ø³Ù… ---
        // Ø¯Ø§Ø¦Ø±Ø© Ù…ØªØ¯Ø§Ø®Ù„Ø© Ù„ØªØ¨Ø¯Ùˆ ÙƒØ§Ù„Ø­ÙŠØ©
        ctx.fillStyle = (i % 2 === 0) ? SNAKE_COLOR_1 : SNAKE_COLOR_2;
        ctx.beginPath();
        ctx.arc(0, 0, tile * 0.55, 0, Math.PI*2);
        ctx.fill();
        // Ù„Ù…Ø¹Ø©
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath(); ctx.arc(-tile*0.1, -tile*0.1, tile*0.2, 0, Math.PI*2); ctx.fill();
      }

      ctx.restore();
    }
  }

  function showToast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    setTimeout(() => t.classList.remove("show"), 1500);
  }

  function updateUI() {
    document.getElementById("score").textContent = state.score;
    document.getElementById("eaten").textContent = state.eaten;
  }

  function gameOver() {
    state.running = false;
    playMarioDeath(); // Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ø³Ø§Ø±Ø©
    document.querySelector("#overlay h2").textContent = "ğŸ’” Ø·ÙŠØ­ Ø§Ù„Ù„Ù‡ Ø­Ø¶Ùƒ ÙŠØ§ Ù…Ø·ÙŠ ÙŠØ§ Ø¨ÙƒØ±";
    document.querySelector("#overlay p").innerHTML = `Ø¬Ù…Ø¹Øª ${state.eaten} Ø­Ø°Ø§Ø¡.<br>Ø§Ù„Ø¹Ø¨ Ø§Ù„Ù†ÙˆØ¨ ÙˆÙƒÙ„ Ø¨ÙƒØ± ÙƒÙ… Ù‚Ù†Ø¯Ø±Ø©!`;
    document.getElementById("startBtn").textContent = "Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨";
    document.getElementById("overlay").style.display = "flex";
  }

  function win() {
    state.running = false;
    playVictorySound();
    document.querySelector("#overlay h2").textContent = "ğŸ‰ ÙØ²Øª!";
    document.querySelector("#overlay p").textContent = "Ø¨Ø§Ù„Ø¹Ø§ÙÙŠØ© ÙŠØ§ ÙØ³Ø¨Ø¹ ! ÙˆÙƒÙ„Øª Ø¨ÙƒÙˆØ±ÙŠ ÙƒÙ„ Ø§Ù„Ø£Ø­Ø°ÙŠØ©.";
    document.getElementById("startBtn").textContent = "ÙŠÙ„Ø§ Ù†ÙˆÙƒÙ„ Ø¨ÙƒØ± ÙƒÙ… Ø­Ø°Ø§ Ù…Ø±Ø© Ø§Ù„Ù†ÙˆØ¨";
    document.getElementById("overlay").style.display = "flex";
  }

  // Init
  init();

</script>
</body>
</html>

